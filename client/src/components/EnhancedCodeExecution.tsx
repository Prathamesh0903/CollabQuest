import React, { useState, useCallback, useRef, useEffect } from 'react';
import './EnhancedCodeExecution.css';

// Types for enhanced code execution
interface CodeExecutionRequest {
  language: string;
  code: string;
  input?: string;
  timeout?: number;
  memoryLimit?: string;
  sessionId?: string;
}

interface CodeExecutionResponse {
  success: boolean;
  stdout?: string;
  stderr?: string;
  compile_output?: string;
  status?: 'success' | 'error' | 'timeout';
  executionTime?: number;
  error?: string;
  generated_files?: Array<{
    name: string;
    size: number;
    path: string;
  }>;
  metrics?: {
    codeLength: number;
    executionDuration: number;
    language: string;
    memoryUsed?: string;
  };
  runtime_logs?: Array<{
    timestamp: string;
    level: string;
    message: string;
    details?: any;
  }>;
}

interface FileInfo {
  name: string;
  size: number;
  modified: Date;
  path: string;
}

interface InteractiveSession {
  sessionId: string;
  language: string;
  code: string;
  status: 'ready' | 'running' | 'terminated';
}

const EnhancedCodeExecution: React.FC = () => {
  const [code, setCode] = useState<string>(`# Enhanced Code Execution Example
# This supports file upload/download and interactive stdin

import os
import sys

print("Hello from enhanced code execution!")
print(f"Current working directory: {os.getcwd()}")
print(f"Files in directory: {os.listdir('.')}")

# Example: Read from a file if it exists
try:
    with open('input.txt', 'r') as f:
        content = f.read()
        print(f"File content: {content}")
except FileNotFoundError:
    print("No input.txt file found")

# Example: Write to a file
with open('output.txt', 'w') as f:
    f.write("This file was generated by the code execution!")

print("Code execution completed! ðŸŽ‰")`);

  const [language, setLanguage] = useState<string>('python');
  const [customInput, setCustomInput] = useState<string>('');
  const [terminalOutput, setTerminalOutput] = useState<string>('');
  const [isExecuting, setIsExecuting] = useState<boolean>(false);
  const [executionMode, setExecutionMode] = useState<'basic' | 'files' | 'interactive'>('basic');
  const [uploadedFiles, setUploadedFiles] = useState<File[]>([]);
  const [sessionFiles, setSessionFiles] = useState<FileInfo[]>([]);
  const [sessionId, setSessionId] = useState<string>('');
  const [interactiveSession, setInteractiveSession] = useState<InteractiveSession | null>(null);
  const [interactiveInput, setInteractiveInput] = useState<string>('');
  const [interactiveOutput, setInteractiveOutput] = useState<string>('');
  const [isInteractiveRunning, setIsInteractiveRunning] = useState<boolean>(false);
  
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Supported languages
  const supportedLanguages = [
    { id: 'javascript', name: 'JavaScript', extension: 'js' },
    { id: 'python', name: 'Python', extension: 'py' },
    { id: 'java', name: 'Java', extension: 'java' },
    { id: 'cpp', name: 'C++', extension: 'cpp' },
    { id: 'csharp', name: 'C#', extension: 'cs' },
    { id: 'typescript', name: 'TypeScript', extension: 'ts' },
    { id: 'go', name: 'Go', extension: 'go' },
    { id: 'rust', name: 'Rust', extension: 'rs' },
    { id: 'php', name: 'PHP', extension: 'php' },
    { id: 'ruby', name: 'Ruby', extension: 'rb' }
  ];

  // Generate session ID on component mount
  useEffect(() => {
    setSessionId(`session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`);
  }, []);

  // Basic code execution
  const executeCodeBasic = useCallback(async () => {
    if (!code.trim()) {
      alert('Please enter some code to execute');
      return;
    }

    setIsExecuting(true);
    setTerminalOutput('');

    try {
      const requestBody: CodeExecutionRequest = {
        language,
        code,
        input: customInput
      };

      console.log('Sending basic code execution request:', requestBody);

      const response = await fetch('http://localhost:5001/api/execute', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody)
      });

      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        const text = await response.text();
        console.error('Received HTML instead of JSON:', text.substring(0, 200));
        throw new Error(`Server returned ${response.status} with non-JSON response. Please check if the server is running.`);
      }

      const result: any = await response.json();
      console.log('Basic code execution result:', result);

      if (result.success) {
        const stdout = result.data?.stdout ?? result.stdout;
        const stderr = result.data?.stderr ?? result.stderr;
        const compile = result.data?.compile_output ?? result.compile_output;
        const execMs = result.execution?.duration_ms ?? result.executionTime;
        let output = '';
        if (stdout) output += `STDOUT:\n${stdout}\n\n`;
        if (stderr) output += `STDERR:\n${stderr}\n\n`;
        if (compile) output += `COMPILE OUTPUT:\n${compile}\n\n`;
        if (execMs) output += `Execution time: ${execMs}ms\n`;
        setTerminalOutput(output);
      } else {
        setTerminalOutput(`Error: ${result.error || 'Execution failed'}`);
      }

    } catch (error) {
      console.error('Basic code execution error:', error);
      
      let errorMessage = (error as Error).message;
      
      if (errorMessage.includes('Failed to fetch')) {
        errorMessage = 'Cannot connect to server. Please ensure the server is running on http://localhost:5001';
      } else if (errorMessage.includes('Unexpected token')) {
        errorMessage = 'Server returned invalid response. This usually means the server is not running or there\'s a configuration issue.';
      }
      
      setTerminalOutput(`Failed to execute code: ${errorMessage}`);
    } finally {
      setIsExecuting(false);
    }
  }, [code, language, customInput]);

  // Code execution with files
  const executeCodeWithFiles = useCallback(async () => {
    if (!code.trim()) {
      alert('Please enter some code to execute');
      return;
    }

    setIsExecuting(true);
    setTerminalOutput('');

    try {
      const formData = new FormData();
      formData.append('language', language);
      formData.append('code', code);
      formData.append('input', customInput);
      formData.append('sessionId', sessionId);

      // Add uploaded files
      uploadedFiles.forEach(file => {
        formData.append('files', file);
      });

      console.log('Sending code execution with files request:', {
        language,
        code: code.substring(0, 100) + '...',
        files: uploadedFiles.map(f => f.name),
        sessionId
      });

      const response = await fetch('http://localhost:5001/api/execute/with-files', {
        method: 'POST',
        body: formData
      });

      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        const text = await response.text();
        console.error('Received HTML instead of JSON:', text.substring(0, 200));
        throw new Error(`Server returned ${response.status} with non-JSON response.`);
      }

      const result: any = await response.json();
      console.log('Code execution with files result:', result);

      if (result.success) {
        const stdout = result.data?.stdout ?? result.stdout;
        const stderr = result.data?.stderr ?? result.stderr;
        const compile = result.data?.compile_output ?? result.compile_output;
        const execMs = result.execution?.duration_ms ?? result.executionTime;
        let output = '';
        if (stdout) output += `STDOUT:\n${stdout}\n\n`;
        if (stderr) output += `STDERR:\n${stderr}\n\n`;
        if (compile) output += `COMPILE OUTPUT:\n${compile}\n\n`;
        if (execMs) output += `Execution time: ${execMs}ms\n`;
        const generated: Array<{ name: string; size: number; path?: string }> =
          result.data?.generated_files ?? result.generated_files ?? [];
        if (generated.length > 0) {
          output += `Generated files:\n`;
          generated.forEach((file) => {
            output += `- ${file.name} (${file.size} bytes)\n`;
          });
          output += '\n';
        }
        setTerminalOutput(output);
        await loadSessionFiles();
      } else {
        setTerminalOutput(`Error: ${result.error || 'Execution failed'}`);
      }

    } catch (error) {
      console.error('Code execution with files error:', error);
      
      let errorMessage = (error as Error).message;
      
      if (errorMessage.includes('Failed to fetch')) {
        errorMessage = 'Cannot connect to server. Please ensure the server is running on http://localhost:5001';
      }
      
      setTerminalOutput(`Failed to execute code: ${errorMessage}`);
    } finally {
      setIsExecuting(false);
    }
  }, [code, language, customInput, uploadedFiles, sessionId]);

  // Load session files
  const loadSessionFiles = useCallback(async () => {
    try {
      const response = await fetch(`http://localhost:5001/api/execute/files/${sessionId}`);
      const result = await response.json();
      
      if (result.success) {
        setSessionFiles(result.data.files || []);
      }
    } catch (error) {
      console.error('Failed to load session files:', error);
    }
  }, [sessionId]);

  // Download file
  const downloadFile = useCallback(async (filename: string) => {
    try {
      const response = await fetch(`http://localhost:5001/api/execute/files/${sessionId}/${filename}`);
      
      if (response.ok) {
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
      } else {
        alert('Failed to download file');
      }
    } catch (error) {
      console.error('Download error:', error);
      alert('Failed to download file');
    }
  }, [sessionId]);

  // Handle file upload
  const handleFileUpload = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(event.target.files || []);
    setUploadedFiles(prev => [...prev, ...files]);
  }, []);

  // Remove uploaded file
  const removeUploadedFile = useCallback((index: number) => {
    setUploadedFiles(prev => prev.filter((_, i) => i !== index));
  }, []);

  // Create interactive session
  const createInteractiveSession = useCallback(async () => {
    if (!code.trim()) {
      alert('Please enter some code to execute');
      return;
    }

    try {
      const requestBody = {
        language,
        code,
        sessionId
      };

      const response = await fetch('http://localhost:5001/api/execute/interactive', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody)
      });

      const result = await response.json();

      if (result.success) {
        setInteractiveSession({
          sessionId: result.data.session_id,
          language,
          code,
          status: 'ready'
        });
        setInteractiveOutput('Interactive session created! Type your input below.\n');
      } else {
        alert(`Failed to create interactive session: ${result.error?.message}`);
      }
    } catch (error) {
      console.error('Create interactive session error:', error);
      alert('Failed to create interactive session');
    }
  }, [code, language, sessionId]);

  // Send interactive input
  const sendInteractiveInput = useCallback(async () => {
    if (!interactiveSession || !interactiveInput.trim()) return;

    setIsInteractiveRunning(true);
    setInteractiveSession(prev => prev ? { ...prev, status: 'running' } : null);

    try {
      const response = await fetch(`http://localhost:5001/api/execute/interactive/${interactiveSession.sessionId}/input`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ input: interactiveInput })
      });

      const result = await response.json();

      if (result.success) {
        setInteractiveOutput(prev => prev + `\n> ${interactiveInput}\n${result.data.output || ''}`);
        setInteractiveInput('');
      } else {
        setInteractiveOutput(prev => prev + `\nError: ${result.error?.message}\n`);
      }
    } catch (error) {
      console.error('Send interactive input error:', error);
      setInteractiveOutput(prev => prev + `\nError: Failed to send input\n`);
    } finally {
      setIsInteractiveRunning(false);
      setInteractiveSession(prev => prev ? { ...prev, status: 'ready' } : null);
    }
  }, [interactiveSession, interactiveInput]);

  // Terminate interactive session
  const terminateInteractiveSession = useCallback(async () => {
    if (!interactiveSession) return;

    try {
      await fetch(`http://localhost:5001/api/execute/interactive/${interactiveSession.sessionId}`, {
        method: 'DELETE'
      });

      setInteractiveSession(null);
      setInteractiveOutput(prev => prev + '\nSession terminated.\n');
    } catch (error) {
      console.error('Terminate session error:', error);
    }
  }, [interactiveSession]);

  // Load session files on mount
  useEffect(() => {
    loadSessionFiles();
  }, [loadSessionFiles]);

  return (
    <div className="enhanced-code-execution">
      <div className="execution-header">
        <h2>Enhanced Code Execution</h2>
        <p>Support for file upload/download and interactive stdin</p>
      </div>

      <div className="execution-content">
        {/* Mode Selector */}
        <div className="mode-selector">
          <label>Execution Mode:</label>
          <div className="mode-buttons">
            <button 
              className={executionMode === 'basic' ? 'active' : ''}
              onClick={() => setExecutionMode('basic')}
            >
              Basic
            </button>
            <button 
              className={executionMode === 'files' ? 'active' : ''}
              onClick={() => setExecutionMode('files')}
            >
              With Files
            </button>
            <button 
              className={executionMode === 'interactive' ? 'active' : ''}
              onClick={() => setExecutionMode('interactive')}
            >
              Interactive
            </button>
          </div>
        </div>

        {/* Language Selector */}
        <div className="language-selector">
          <label htmlFor="language-select">Programming Language:</label>
          <select
            id="language-select"
            value={language}
            onChange={(e) => setLanguage(e.target.value)}
          >
            {supportedLanguages.map(lang => (
              <option key={lang.id} value={lang.id}>
                {lang.name}
              </option>
            ))}
          </select>
        </div>

        {/* Code Editor */}
        <div className="code-editor-section">
          <div className="editor-header">
            <h3>Code Editor</h3>
            <div className="editor-controls">
              {executionMode === 'basic' && (
                <button 
                  className="execute-btn basic" 
                  onClick={executeCodeBasic}
                  disabled={isExecuting}
                >
                  {isExecuting ? 'Executing...' : 'Execute Basic'}
                </button>
              )}
              {executionMode === 'files' && (
                <button 
                  className="execute-btn files" 
                  onClick={executeCodeWithFiles}
                  disabled={isExecuting}
                >
                  {isExecuting ? 'Executing...' : 'Execute with Files'}
                </button>
              )}
              {executionMode === 'interactive' && (
                <button 
                  className="execute-btn interactive" 
                  onClick={createInteractiveSession}
                  disabled={!!interactiveSession}
                >
                  {interactiveSession ? 'Session Active' : 'Start Interactive Session'}
                </button>
              )}
            </div>
          </div>
          
          <textarea
            className="code-editor"
            value={code}
            onChange={(e) => setCode(e.target.value)}
            placeholder="Enter your code here..."
            rows={15}
          />
        </div>

        {/* File Upload Section (for files mode) */}
        {executionMode === 'files' && (
          <div className="file-upload-section">
            <h3>File Upload</h3>
            <div className="file-upload-controls">
              <input
                ref={fileInputRef}
                type="file"
                multiple
                onChange={handleFileUpload}
                style={{ display: 'none' }}
                accept=".py,.js,.ts,.java,.cpp,.c,.cs,.go,.rs,.php,.rb,.html,.css,.json,.xml,.txt,.md,.sql,.sh,.bat,.csv,.dat,.log,.cfg,.ini,.yml,.yaml"
              />
              <button 
                className="upload-btn"
                onClick={() => fileInputRef.current?.click()}
              >
                Choose Files
              </button>
              <span className="file-info">
                {uploadedFiles.length} file(s) selected
              </span>
            </div>
            
            {uploadedFiles.length > 0 && (
              <div className="uploaded-files">
                <h4>Uploaded Files:</h4>
                <ul>
                  {uploadedFiles.map((file, index) => (
                    <li key={index}>
                      {file.name} ({(file.size / 1024).toFixed(2)} KB)
                      <button 
                        className="remove-file-btn"
                        onClick={() => removeUploadedFile(index)}
                      >
                        Ã—
                      </button>
                    </li>
                  ))}
                </ul>
              </div>
            )}
          </div>
        )}

        {/* Custom Input */}
        <div className="input-section">
          <label htmlFor="custom-input">Custom Input (optional):</label>
          <textarea
            id="custom-input"
            className="custom-input"
            value={customInput}
            onChange={(e) => setCustomInput(e.target.value)}
            placeholder="Enter input data for your code..."
            rows={3}
          />
        </div>

        {/* Interactive Input (for interactive mode) */}
        {executionMode === 'interactive' && interactiveSession && (
          <div className="interactive-section">
            <h3>Interactive Input</h3>
            <div className="interactive-controls">
              <textarea
                className="interactive-input"
                value={interactiveInput}
                onChange={(e) => setInteractiveInput(e.target.value)}
                placeholder="Type your input here..."
                rows={3}
                onKeyPress={(e) => {
                  if (e.key === 'Enter' && e.ctrlKey) {
                    e.preventDefault();
                    sendInteractiveInput();
                  }
                }}
              />
              <div className="interactive-buttons">
                <button 
                  className="send-input-btn"
                  onClick={sendInteractiveInput}
                  disabled={isInteractiveRunning || !interactiveInput.trim()}
                >
                  {isInteractiveRunning ? 'Sending...' : 'Send Input (Ctrl+Enter)'}
                </button>
                <button 
                  className="terminate-btn"
                  onClick={terminateInteractiveSession}
                >
                  Terminate Session
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Terminal Output */}
        <div className="terminal-section">
          <div className="terminal-header">
            <h3>Execution Output</h3>
            <button 
              className="clear-btn" 
              onClick={() => {
                setTerminalOutput('');
                setInteractiveOutput('');
              }}
            >
              Clear
            </button>
          </div>
          
          <div className="terminal-content">
            {isExecuting && (
              <div className="terminal-loading">
                <div className="loading-spinner"></div>
                <span>Executing code...</span>
              </div>
            )}

            {executionMode === 'interactive' && interactiveSession ? (
              <pre className="terminal-output interactive">
                {interactiveOutput}
                {isInteractiveRunning && 'Waiting for response...\n'}
              </pre>
            ) : (
              <pre className="terminal-output">
                {terminalOutput || 'No output yet. Execute some code to see results.'}
              </pre>
            )}
          </div>
        </div>

        {/* Session Files (for files mode) */}
        {executionMode === 'files' && sessionFiles.length > 0 && (
          <div className="session-files-section">
            <h3>Session Files</h3>
            <div className="files-list">
              {sessionFiles.map((file, index) => (
                <div key={index} className="file-item">
                  <span className="file-name">{file.name}</span>
                  <span className="file-size">({(file.size / 1024).toFixed(2)} KB)</span>
                  <button 
                    className="download-btn"
                    onClick={() => downloadFile(file.name)}
                  >
                    Download
                  </button>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default EnhancedCodeExecution;
